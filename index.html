<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="伴我同行">
<meta property="og:type" content="website">
<meta property="og:title" content="Chenper's Home">
<meta property="og:url" content="http://chenper.github.com/index.html">
<meta property="og:site_name" content="Chenper's Home">
<meta property="og:description" content="伴我同行">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chenper's Home">
<meta name="twitter:description" content="伴我同行">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://chenper.github.com/"/>

  <title> Chenper's Home </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Chenper's Home</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/10/高性能MySQL/" itemprop="url">
                  高性能MySQL
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-10T00:00:00+08:00" content="2016-08-10">
              2016-08-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/10/高性能MySQL/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/10/高性能MySQL/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><a href="#1">MySQL基础</a> </li>
<li><a href="#2">数据类型优化</a></li>
<li><a href="#3">高性能索引</a></li>
<li><a href="#4">查询性能优化</a></li>
<li><a href="#5">MySQL高级特性</a> </li>
<li><a href="#6">MySQL参数配置</a><br><h2 id="1">1.MySQL基础</h2><br><strong>逻辑架构</strong><br>客户端<br>解析优化缓存等跨存储引擎功能<br>存储引擎<br><strong>并发控制</strong><ul>
<li>读写锁<ul>
<li>读锁：共享锁</li>
<li>写锁：排它锁</li>
</ul>
</li>
<li>锁粒度<ul>
<li>表锁</li>
<li>行锁：并发能力更好，但锁的开销越大<br><strong>事务</strong><br>原子性的数据操作<br>ACID：原子性，一致性，隔离性，持久性<br><strong>隔离级别</strong></li>
</ul>
</li>
<li>未提交读：脏读</li>
<li>提交读：只能看见已经提交修改，在事务过程中可能被修改</li>
<li>可重复读:MySQL默认，事物中多次读取一致</li>
<li>可串行化：加锁，强调事务串行执行<br><strong>InnoDB与myISAM</strong></li>
<li>InnoDB：默认引擎，隔离级别可重复读，存储在表文件中，支持事务，用来处理大量短期事务，支持外键，行级锁</li>
<li>myISAM：不支持事务与外键，表级锁，无法安全恢复，多用于多读多插入或较小的表，分开存储在数据文件和索引文件中。</li>
<li>修改表的存储引擎<ul>
<li>ALERT TABLE ENGINE =</li>
<li>导出到文件，修改后再导入</li>
<li>创建新表，修改引擎再导入数据<br><h2 id="2">2.数据类型优化</h2><br>更小更简单就好，经量避免null</li>
</ul>
</li>
<li>整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT</li>
<li>实数类型：FLOAT、DOUBLE、DECIMAL</li>
<li>字符串类型：VARCHAR（变长）CHAR、BLOB（二进制大字符串）、TEXT（字符型大字符串）</li>
<li>时间类型：DATETIME、TIMESTAMP</li>
<li>位数据类型：BIT、SET<br><strong>范式</strong></li>
<li>第一范式（1NF）：属性不可分</li>
<li>第二范式（2NF）：符合1NF，并且，非主属性完全依赖于码。</li>
<li>第三范式（3NF）：符合2NF，并且，消除传递依赖<br>范式的使用与否要结合实际情况<br><strong>缓存表与汇总表</strong><br><strong>加快ALERT TABLE的速度</strong><br>因为每次大部分更改表都会新建一个表，再把数据插入到新建的表中，造成很大的性能开销。<br>一般加速方法是：创建一张同样结构的表，不带索引，接着创建一张空的带数据的表，交换frm和myi文件，再进行后续操作。<br><h2 id="3">3.高性能索引</h2><h3>概论</h3><br>如果对多列进行索引(组合索引)，列的顺序非常重要，MySQL仅能对索引最左边的前缀进行有<br>效的查找。例如：假设存在组合索引it1c1c2(c1,c2)，查询语句select <em> from t1 where<br>c1=1 and c2=2能够使用该索引。查询语句select </em> from t1 where c1=1也能够使用该<br>索引。但是，查询语句select * from t1 where c2=2不能够使用该索引，因为没有组合索<br>引的引导列，即，要想使用c2列进行查找，必需出现c1等于某值。<br><h3>索引类型</h3></li>
<li>B-Tree索引<br>(1) 查询必须从索引的最左边的列开始。（组合索引中）<br>(2) 不能跳过某一索引列。<br>(3) 存储引擎不能使用索引中范围条件右边的列。例如，如果你的查询语句为WHERE last_name=”Smith” AND first_name LIKE ‘J%’ AND dob=’1976-12-23’，则该查询只会使用索引中的前两列，因为LIKE是范围查询。</li>
<li>Hash索引<br>(1)由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录。但是访问内存中的记录是非常迅速的，不会对性造成太大的影响。<br>(2)不能使用hash索引排序。<br>(3)Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。<br>(4)Hash索引只支持等值比较，例如使用=，IN( )和&lt;=&gt;。对于WHERE price&gt;100并不能加速查询。<h3>高性能索引策略</h3></li>
<li>索引列不能是表达式的一部分，也不能是参数</li>
<li>选择合适的前缀索引以保持选择性</li>
<li>选择合适的索引列顺序（多个单列索引）</li>
<li>聚簇索引<ul>
<li>保证表的物理地址顺序与索引顺序一致，一个表只能有一个聚簇索引</li>
</ul>
</li>
<li>覆盖索引<ul>
<li>如果索引包含满足查询的所有数据，就称为覆盖索引。覆盖索引能大大提高查询性能。只需要读取索引而不用读取数据<br>(1)索引项通常比记录要小，所以MySQL访问更少的数据；<br>(2)索引都按值的大小顺序存储，相对于随机访问记录，需要更少的I/O；<br>3)大多数据引擎能更好的缓存索引。比如MyISAM只缓存索引。<br>(4)覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了。</li>
</ul>
</li>
<li>当MySQL不能使用索引进行排序时，就会利用自己的排序算法(快速排序算法)在内存(sort buffer)中对数据进行排序，</li>
<li>索引对于InnoDB非常重要，因为它可以让查询锁更少的元组。减小开销，增加并发数。<br><h2 id="4">4.查询性能优化</h2><h3>优化数据访问</h3></li>
<li>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列。<ul>
<li>查询不需要的记录加上limit</li>
<li>多表关联时返回全部列</li>
<li>总是取出所有的数据</li>
<li>重复查询相同的数据，使用缓存</li>
</ul>
</li>
<li>确认MySQL服务器层是否在分析大量超过需要的数据行<ul>
<li>响应时间</li>
<li>访问的行数与返回的行数</li>
<li>扫描的行数与访问类型<h3>重构查询方式</h3></li>
</ul>
</li>
<li>选择复杂查询还是简单查询</li>
<li>切分查询</li>
<li>分解关联查询<h3>查询执行基础</h3></li>
<li>客户端服务端通信协议</li>
<li>查询缓存</li>
<li>查询优化处理<ul>
<li>语法解析，预处理，查询优化,排序优化</li>
</ul>
</li>
<li>返回结果给客户端<br><strong>排序优化</strong><br>两次传输排序：读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。显然是两次传输，特别是读取排序后的数据时（第二次）大量随机I/O，所以两次传输成本高。<br>单次排序传输：先读取查询所需所有列，再根据给定列进行排序，最后直接返回排序结果。<br><h3>查询优化的局限性</h3><br><h3>查询优化的提示</h3><br><h3>优化特定类型的查询</h3><br><h2 id="5">5.MySQL高级特性</h2><br><h3>分区表</h3><br>分区表是一种粗粒度,简易的索引策略,适用于大数据的过滤场景.最适合的场景是,没有合适的索引时,对其中几个分区表进行全表扫描.或者只有一个分区表和索引是热点,而且这个分区和索引能够全部存储在内存中.限制单表分区数不要超过150个,并且注意某些导致无法做分区过滤的细节,分区表对于单条记录的查询没有优势,需要注意这类查询的性能.<br><strong>大量数据下的分区表</strong><br>对于大数据(如10TB)而言,索引起到的作用相对小,因为索引的空间与维护成本很高,另外如果不是索引覆盖查询,将导致回表,造成大量磁盘IO.那么对于这种情况的解决策略是:<br>1.全量扫描数据,不要任何索引，通过分区表表达式将数据定位在少量的分区表,然后正常访问这些分区表的数据<br>2.分离热点,索引数据将热点数据分离出来在一个小的分区,并对分区建立索引,对热点数据的查询提高效率.<br><h3>视图</h3><br>视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。<br>对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。<br>1、 视图能简化用户操作<br>2、 视图使用户能以多种角度看待同一数据<br>3、 视图对重构数据库提供了一定程度的逻辑独立性<br>4、视图能够对机密数据提供安全保护<br>5、适当的利用视图可以更清晰地表达查询<br><h3>外键</h3><br>外键的使用条件：<br>1.两个表必须是InnoDB表，MyISAM表暂时不支持外键（据说以后的版本有可能支持，但至少目前不支持）；<br>2.外键列必须建立了索引，MySQL 4.1.2以后的版本在建立外键时会自动创建索引，但如果在较早的版本则需要显示建立；<br>3.外键关系的两个表的列必须是数据类型相似，也就是可以相互转换类型的列，比如int和tinyint可以，而int和char则不可以；</li>
</ul>
</li>
</ul>
<p>外键的好处：可以使得两张表关联，保证数据的一致性和实现一些级联操作；<br>外键不必是主键，但必须是唯一性索引；</p>
<p></p><h3>存储过程</h3><br>我们常用的操作数据库语言SQL语句在执行的时候需要要先编译，然后执行，而存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给定参数（如果该存储过程带有参数）来调用执行它。<p></p>
<ul>
<li>存储过程增强了SQL语言的功能和灵活性。</li>
<li>存储过程能实现较快的执行速度</li>
<li>存储过程能过减少网络流量</li>
<li>存储过程可被作为一种安全机制来充分利用<br><h3>触发器</h3><br>MySQL包含对触发器的支持。触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。</li>
</ul>
<p>trigger_time：标识触发时机，取值为 BEFORE 或 AFTER；<br>trigger_event：标识触发事件，取值为 INSERT、UPDATE 或 DELETE；</p>
<p>①如果 BEFORE 触发器执行失败，SQL 无法正确执行。<br>②SQL 执行失败时，AFTER 型触发器不会触发。<br>③AFTER 类型的触发器执行失败，SQL 会回滚。</p>
<p></p><h3>事件</h3><br>在系统管理或者数据库管理中，经常要周期性的执行某一个命令或者SQL语句。对于linux系统熟悉的人都知道linux的cron计划任务，能很方便地实现定期运行指定命令的功能。Mysql在5.1以后推出了事件调度器(Event Scheduler)，和linux的cron功能一样，能方便地实现 mysql数据库的计划任务，而且能精确到秒。使用起来非常简单和方便。<p></p>
<p></p><h3>全文索引</h3><br>先定义一个词库，然后在文章中查找每个词条(term)出现的频率和位置，把这样的频率和位置信息按照词库的顺序归纳，这样就相当于对文件建立了一个以词库为目录的索引，这样查找某个词的时候就能很快的定位到该词出现的位置。<p></p>
<p></p><h3>缓存</h3><br>缓存存在一个hash表中,通过查询SQL,查询数据库,客户端协议等作为key.在判断是否命中前,MySQL不会解析SQL,而是直接使用SQL去查询缓存,SQL任何字符上的不同,如空格,注释,都会导致缓存不命中.<p></p>
<p>如果查询中有不确定数据,例如CURRENT_DATE()和NOW()函数,那么查询完毕后则不会被缓存.所以,包含不确定数据的查询是肯定不会找到可用缓存的</p>
<p></p><h2 id="6">6.MySQL参数配置</h2><br>MySQL的配置参数太多太复杂，需要深入的项目实践应用相结合，这里只列出相关的几个重要参数<br><strong>基本参数</strong><p></p>
<ul>
<li>innodb_buffer_pool_size：数据和索引缓存池的大小</li>
<li>innodb_log_file_size：redo日志的大小</li>
<li>max_connections:最大连接数<br><strong>innodb配置</strong></li>
<li>query_cache_size:查询缓存</li>
<li>innodb_log_buffer_size: 这项配置决定了为尚未执行的事务分配的缓存。</li>
<li>innodb_flush_method: 这项配置决定了数据和日志写入硬盘的方式。<br><strong>RAID</strong><br>独立磁盘构成的具有冗余能力的阵列，由很多价格较便宜的磁盘，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/05/Java虚拟机/" itemprop="url">
                  《深入理解Java虚拟机》读书笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-05T22:43:01+08:00" content="2016-08-05">
              2016-08-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/05/Java虚拟机/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/05/Java虚拟机/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><a href="#1">内存管理机制</a> </li>
<li><a href="#2">虚拟机执行子系统</a></li>
<li><a href="#3">程序编译与代码优化</a></li>
<li><a href="#4">高效并发</a><br><h2 id="1">内存管理机制</h2><br><h3> 1.Java内存区域</h3><br><strong>线程私有</strong></li>
</ul>
<ul>
<li>程序计数器<ul>
<li>指向当前线程正在执行的指令</li>
</ul>
</li>
<li>虚拟机栈<ul>
<li>与线程生命周期相同，存储局部变量，方法出口，操作数栈等参数</li>
</ul>
</li>
<li>本地方法栈<ul>
<li>执行Native方法时使用</li>
</ul>
</li>
</ul>
<p><strong>线程共有</strong></p>
<ul>
<li>Java堆<ul>
<li>存放对象实例，GC主要区域</li>
</ul>
</li>
<li>方法区<ul>
<li>存储加载后的类信息，常量，静态变量，编译后的代码等等</li>
</ul>
</li>
<li>运行时常量池<ul>
<li>属于方法区，保存编译期生成的字面量和符号引用</li>
</ul>
</li>
<li>直接内存<h3>2.垃圾回收GC</h3></li>
<li>引用计数法</li>
<li>可达性分析法<ul>
<li>从GC root向下搜索，若没有引用链链接到对象则视为不可达</li>
</ul>
</li>
</ul>
<p><strong>垃圾收集算法</strong></p>
<ul>
<li>标记清除算法<ul>
<li>标记出需要回收的对象，标记完成后统一回收</li>
</ul>
</li>
<li>复制算法<ul>
<li>当内存使用完之后，将存活的对象复制到另外的区域，把使用过的内存清理</li>
<li>Eden区与两个survivor区域，每次清理Eden与survivor区域，再复制到另一个survivor</li>
</ul>
</li>
<li>标记整理算法<ul>
<li>标记出不需要回收的对象，移动整理，把其他对象清理</li>
</ul>
</li>
<li>分代收集方法<ul>
<li>根据是老年代还是新生代采用不同的回收算法<blockquote>
<p>stop the world，safepoint 进行GC时需要暂停其他工作<br><strong>内存分配与回收策略</strong><br>对象优先在新生代Eden区分配，没有空间时，发生一次Minor Gc；<br>大对象直接进入老年代<br>长期存活对象进入老年代<br>动态对象年龄判定：对象进入老年代的年龄是动态判定的</p>
<h3>3.虚拟机监控与处理</h3></blockquote>
</li>
</ul>
</li>
<li>jps:虚拟机进程状况工具</li>
<li>jstat:虚拟机统计信息监视工具</li>
<li>jinfo:Java配置信息工具</li>
<li>jmap:java内存映像工具</li>
<li>jstack:Java堆栈跟踪工具</li>
<li>jconsole:java可视化监视与管理平台<br><h2 id="2">虚拟机执行子系统</h2> <h3>1.概述</h3>

</li>
</ul>
<p><strong>class类文件结构</strong></p>
<ul>
<li>魔数:0xCAFEBABE</li>
<li>class文件版本</li>
<li>常量池</li>
<li>访问标志：public，final，标志是接口之类的信息</li>
<li>类索引，接口索引，父索引：确定继承关系</li>
<li>字段表集合：描述申明的变量，不包括局部变量</li>
<li>方法表集合：描述类中的方法</li>
<li>属性表集合：描述其他属性<br><strong>字节码指令</strong><br>  参考汇编，针对不同的数据类型，有加载，存储，运算，类型转换，控制转移，方法调用与返<br>  回等指令，还有对象创建，栈管理，异常处理等指令<br><strong>公有设计与私有实现</strong><br>  Class文件格式及字节码指令集是通用的，与硬件或者具体的java虚拟机实现无关<br><h3>2.虚拟机类加载机制</h3><br><strong>类的生命周期</strong><br>加载-&gt;连接(验证，准备，解析)-&gt;初始化-&gt;使用-&gt;卸载</li>
</ul>
<p><strong>必须初始化</strong></p>
<ul>
<li>new实例化对象，读取静态字段，调用静态方法时</li>
<li>运用反射对类进行调用时</li>
<li>初始化一个子类，而父类还未初始化</li>
<li>包含main方法的那个类等等</li>
</ul>
<p><strong>类加载的过程</strong></p>
<ul>
<li>加载<ul>
<li>获取类的二进制字符流</li>
<li>将静态存储结构转化为运行时数据结构，存储在方法区中</li>
<li>生成java.lang.Class对象作为类的访问入口</li>
</ul>
</li>
<li>验证<ul>
<li>验证Class文件的字节流符合当前虚拟机的要求，不会危害虚拟机安全</li>
</ul>
</li>
<li>准备<ul>
<li>为类变量赋初始值</li>
</ul>
</li>
<li>解析<ul>
<li>将符号应用替换为直接引用（对应class字节流里的内容（符号引用）找到匹配）</li>
</ul>
</li>
<li>初始化<ul>
<li>真正开始执行字节码</li>
</ul>
</li>
</ul>
<p><strong>初始化顺序</strong><br>1.继承体系的所有静态成员初始化（先父类，后子类）<br>2.父类初始化完成（普通成员的初始化–&gt;构造函数的调用）<br>3.子类初始化（普通成员–&gt;构造函数）</p>
<p><strong>类加载器</strong><br>只有类加载器相同的情况下，两个类是否相同才有意义</p>
<ul>
<li>启动类加载器（Bootstrap）</li>
<li>扩展类加载器（Extension）</li>
<li>应用程序加载类（Application）</li>
<li>自定义加载类<br><strong>双亲委派模型</strong><br>当加载器收到一个请求之后，他会向上传递，直到启动类加载器，只有父加载器处理不了这个任务时，子加载器才会尝试自己去加载。<br><h3>3.执行引擎</h3><br><strong>运行时栈帧结构</strong></li>
<li>局部变量表</li>
<li>操作数栈</li>
<li>动态连接（常量池）</li>
<li>方法返回地址<br><strong>方法调用</strong></li>
<li>解析：在编译期确定，确定被调用方法的版本，符号应用-&gt;直接引用</li>
<li>分派<ul>
<li>静态分派：类似于重载，编译期可知，调用默认选择的方法</li>
<li>动态分派：类似于重写，运行时确定，调用动态选择的方法</li>
</ul>
</li>
<li>附加信息<br><h2 id="3">程序编译与代码优化</h2> <h3>1.编译期优化</h3></li>
<li>解析与填充符号表<ul>
<li>词法，语法分析：生成抽象语法树</li>
<li>填充符号表</li>
</ul>
</li>
<li>注解处理器</li>
<li>语义分析与字节码生成：检查是否符合逻辑<ul>
<li>标注检查</li>
<li>数据及控制流分析</li>
<li>解语法糖：泛型（伪泛型），自动装箱拆箱，遍历循环等</li>
<li>字节码生成<br><h3>2.运行期优化</h3><br><strong>编译器与解释器</strong><br>解释器逐行解释执行<br>编译器将字节码优化后生成机器码再运行，执行速度更快<br>Java虚拟器多采用两者混合工作的方式，会将多次调用的方法和循环交给编译器处理<br><strong>编译优化技术</strong></li>
</ul>
</li>
<li>公共子表达式消除</li>
<li>数组辩解检查消除</li>
<li>方法内联</li>
<li>逃逸分析<br><h2 id="4">高效并发</h2><br><h3>1.java内存模型与线程</h3><br><strong>volatile</strong></li>
</ul>
<ol>
<li>volatile变量对所有线程立即可见，但由于java运算不是原子性的，所以不能保证线程安全</li>
<li>禁止指令重排序优化，执行顺序与代码顺序一样<br><strong>原子性，可见性，有序性</strong></li>
</ol>
<ul>
<li>原子性：执行过程中不可被中断</li>
<li>可见性：当一个线程修改变量之后，其他线程立即可知</li>
<li>有序性：在本线程中观察有序，其他线程中观察无序<br><strong>java线程</strong></li>
<li>新建：创建后尚未启动</li>
<li>运行：正在执行或者等待CPU</li>
<li>等待：等待一段时间（sleep）或者等到其他线程唤醒（wait）</li>
<li>阻塞：等待获取一个排它锁</li>
<li>结束：线程执行完<br><h3>2.线程安全与锁优化</h3><blockquote>
<p>关于线程同步和锁具体见其他博文</p>
</blockquote>
</li>
<li>自旋锁：等待另一个锁的时候自己不断循环</li>
<li>锁消除：不存在竞争时取消锁</li>
<li>锁粗化：将多个细粒度锁合并为一个粗粒度的锁</li>
<li>轻量级锁</li>
<li>偏向锁</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/12/TCP-IP/" itemprop="url">
                  Tcp-IP知识整理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-12T10:08:43+08:00" content="2016-07-12">
              2016-07-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/12/TCP-IP/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/12/TCP-IP/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h1>计算机网络知识整理</h1><p></p>
<blockquote>
<p>《Tcp-IP》一书知识整理,要点总结</p>
</blockquote>
<ul>
<li><a href="#1">概述</a> </li>
<li><a href="#2"></a></li>
<li><a href="#3"></a></li>
<li><a href="#4"></a></li>
<li><a href="#5"></a></li>
<li><a href="#6"></a></li>
<li><a href="#7"></a><br><h2 id="1">概述</h2><br>分层：应用层，传输层，网络层，链路层<br>互联网地址：IP地址+端口<br>域名系统：DNS<br>封装与分用：用户数据-&gt;报文段-&gt;数据报-&gt;帧<br><h2 id="2">链路层</h2><br>功能：封装IP数据报，实现ARP协议，实现RARP协议<br>环回接口：当目的地址是127.0.0.1或者localhost的时候，一般省略链路层的功能，把IP输入放到输入队列中，再直接发送到本机。<br>最大传输单元（MTU）：链路层帧的最大长度限制。<br>路径MTU：整个传输路径上的最小MTU。<h3>1.ARP地址解析协议</h3>





</li>
</ul>
<h2 id="4">网络层</h2><br><h3>1.IP网际协议</h3><br>IP协议是不可靠，无连接的。不能保证到达目的地，发生错误则丢弃，且每个数据包都是相互独立的，也不保证按顺序接受。<br>当传输数据过大的时候，可以对IP数据报进行分片。<br>TTL：数据报可经过的最大路由数<br><h3>2.路由选择</h3><br>IP路由是逐跳的进行的，IP报文不知道到目的地的传统路径，只会逐步的搜索路由表，其中，路由表包括：目的IP地址，下一跳IP地址，网络接口等等内容。<br><h3>3.子网掩码</h3><br>1的个数为网络长度，0为主机长度，与IP地址相与可以得到子网地址，网络地址包括网络号和子网号。<br><br><br><br><br><br><br><br><h2 id="6">死锁</h2><br>如果一个进程集合中所有进程都在等待其他进程才能引发的事件，则称<br>该进程集合是死锁的。<br><h3>1.死锁条件</h3><br>    1. 互斥条件<br>    2. 不可抢占条件<br>    3. 占有与等待条件<br>    4. 环路等待条件<br><h3>2.鸵鸟算法</h3><br>假装没看到<br><h3> 3.死锁检测与死锁恢复</h3><br>允许死锁的发生，采取措施进行恢复，恢复方法有：利用抢占恢复；利用回滚恢复；利用杀死进程恢复。<br><h3>4.死锁避免</h3><br>    银行家算法：操作系统按照银行家制定的规则为进程分配资源，当进程<br>    首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的<br>    资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟<br>    分配。当进程在执行中继续申请资源时，先测试该进程本次申请的资源<br>    数是否超过了该资源所剩余的总量。若超过则拒绝分配资源，若能满足<br>    则按当前的申请量分配资源，否则也要推迟分配。<br><h3> 5.死锁预防</h3><br>    破坏互斥条件<br>    破坏占有和等待条件<br>    破坏不可抢占条件<br>    破坏环路等待条件<br><h2 id="7">Linux</h2> 

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/09/java_se/" itemprop="url">
                  javaSE基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-09T10:40:14+08:00" content="2016-07-09">
              2016-07-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/09/java_se/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/09/java_se/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p></p><h2>1.数据类型</h2><p></p>
<ul>
<li>数值型<ul>
<li>整数<ul>
<li>byte：8</li>
<li>short：16</li>
<li>int：32</li>
<li>long：64</li>
</ul>
</li>
<li>浮点<ul>
<li>float：32</li>
<li>double：64</li>
</ul>
</li>
</ul>
</li>
<li>字符型<ul>
<li>char：2</li>
</ul>
</li>
<li>布尔型<ul>
<li>boolean：true or false<br>数值默认由小到大转型，由大到小要强制转换。<br><h2>2.运算符</h2><br>赋值运算：=<br>三目运算：布尔表达式 ? 条件满足 : 条不满足<br>数学运算符：+、-、*、/、%<br>关系运算符：&gt;、&gt;=、&lt;、&lt;=、==、!=<br>位运算：&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;、^、~<br>逻辑运算：&amp;&amp;、&amp;、||、|、!<br>简便运算符：++、–<br><h2>3.程序控制</h2><br>if else,switch,while,do while,for等用法<br><h2>4.方法</h2><br>把某种需要重复调用的功能代码提取出来。<br>public static 返回值类型 方法名称(参数类型 参数名称,…..){<br>  [return 返回值] ;<br>}<br>方法重载：方法名称相同，参数的类型或个数不同<br><h2>5.数组</h2><br>数组是一组相关变量的集合，可由以下方式申明<br>数据类型 数组名称[] = new 数据类型[长度]<br>数据类型 [] 数组名称 = new 数据类型[长度]<br>初始化(默认初始化，静态初始化，动态初始化)<br>二维数组<br><h2>6.面向对象</h2><blockquote>
<p>OOP特性见其他博文</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>构造方法：在一个类中定义的方法名称与类名称相同，且无返回值声明的方法，称为构造方法。若没有明确定义，则自动生成。主要作用就是为一个类中的属性初始化的<br>static 关键字在类中可以声明属性或方法。声明的属性将称为全局属性，声明的方法将成为类方法。<br>在方法中申明内部类<br>    class Outer {<br>        private String info = “hello” ;<br>        public void fun(){<br>            class Inner { // 方法中声明内部类<br>                public void print(){<br>                System.out.println(info) ;<br>                }<br>            };<br>        new Inner().print() ;<br>        }<br>    };</p>
<p></p><h2>7.String类</h2><br>String是不可变对象<br>“==”用在了对象上则表示的是判断两个对象的地址是否相等，String对象的比较可以用equals方法<br>String对象要采用直接赋值的方式完成，用构造方法会产生两个对象。<br>由于String类一旦创建就不能改变，则“+”运算会产生额外的对象，可以参考StringBuild<br>另外还要熟悉常用的字符串操作方法<p></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/06/操作系统/" itemprop="url">
                  操作系统知识整理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-06T18:27:27+08:00" content="2016-07-06">
              2016-07-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/06/操作系统/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/06/操作系统/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>《现代操作系统》一书知识整理,要点总结</p>
</blockquote>
<ul>
<li><a href="#1">概述</a> </li>
<li><a href="#2">进程</a></li>
<li><a href="#3">存储管理</a></li>
<li><a href="#4">文件管理</a></li>
<li><a href="#5">输入输出设备</a></li>
<li><a href="#6">死锁</a></li>
<li><p><a href="#7">初识Linux</a>     </p>
<h2 id="1">概述</h2><br><h3> 1.什么是操作系统</h3><br>操作系统是对底层硬件的抽象，是管理资源的平台。<br>主要任务包括管理资源分配，评估使用代价和调节资源分配的冲突<br><h3>2.计算机硬件组成</h3><br> 处理器、存储器、磁盘、I/O设备等等<br><h3>3.操作系统概念</h3><br> 进程、地址空间、文件、输入输出<br><h3> 4.系统调用</h3><br><h2 id="2">进程</h2><br><h3>1.进程</h3><br> 进程概念：进程（Process）是计算机中的程序关于某数据集合上的一<br> 次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构<br> 的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行<br> 实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序<br> 是指令、数据及其组织形式的描述，进程是程序的实体进程的状态。<br><h3>2.线程</h3><br>线程<br> 线程是进程中的一个实体，是被系统独立调度和分派的基本单<br> 位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资<br> 源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一<br> 个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并<br> 发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。<br> 线程也有就绪、阻塞和运行三种基本状态。<br>临界区：<br> 临界区指的是一个访问共用资源（例如：共用设备或是共用存储器）的<br> 程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线<br> 程进入临界区段时，其他线程或是进程必须等待（例如：bounded<br>  waiting 等待法），有一些同步的机制必须在临界区段的进入点与离<br> 开点实现，以确保这些共用资源是被互斥获得使用，例如：<br> semaphore。只能被单一线程访问的设备，例如：打印机。<br>线程与进程区别：<br> (1)地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间;<br> (2)资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源<br> (3)线程是处理器调度的基本单位,但进程不是,线程更轻量级，切换更快。<br> (4)二者均可并发执行.<br><h3>3.进程间通信</h3><br>管道<br> 管道是进程间通信中最古老的方式，它包括无名管道和有名管道两种，<br> 前者用于父进程和子进程间的通信，后者用于运行于同一台机器上的任<br> 意两个进程间的通信。<br>消息队列<br> 消息队列用于运行于同一台机器上的进程间通信，它和管道很相似，是<br> 一个在系统内核中用来保存消息的队列，它在系统内核中是以消息链表<br> 的形式出现。消息链表中节点的结构用msg声明。事实上，它是一种正<br> 逐渐被淘汰的通信方式，我们可以用流管道或者套接口的方式来取代它。<br>信号<br> 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收<br> 进程某个事件已经发生。<br>共享内存<br> 共享内存是运行在同一台机器上的进程间通信最快的方式，因为数据不<br> 需要在不同的进程间复制。通常由一个进程创建一块共享内存区，其余<br> 进程对这块内存区进行读写。<br>信号量<br> 本质上，信号量是一个计数器，它用来记录对某个资源（如共享内存）<br> 的存取状况。一般说来，为了获得共享资源，进程需要执行下列操作：<br> （1） 测试控制该资源的信号量。<br> （2） 若此信号量的值为正，则允许进行使用该资源。进程将信号量减1。<br> （3） 若此信号量为0，则该资源目前不可用，进程进入睡眠状态，直至信号量值大于0，进程被唤醒，转入步骤（1）。<br> （4） 当进程不再使用一个信号量控制的资源时，信号量值加1。如果此时有进程正在睡眠等待此信号量，则唤醒此进程。<br>套接字<br>  套接口（socket）编程是实现Linux系统和其他大多数操作系统中进<br> 程间通信的主要方式之一。我们熟知的WWW服务、FTP服务、TELNET服<br> 务 等都是基于套接口编程来实现的。除了在异地的计算机进程间以<br> 外，套接口同样适用于本地同一台计算机内部的进程间通信。<br><h3> 4.调度算法</h3><br>先来先服务<br>最短作业优先<br>最短剩余时间优先<br>轮转调度<br>优先级调度<br><h3>5.经典问题</h3><br> 消费者-生产者<br> 哲学家就餐<br> 读者-写者<br><h2 id="3">存储管理</h2><br><h3>1.地址空间</h3><br> 地址空间为程序创造了一种抽象的内存，是一个进程可用于寻址内存的<br> 地址集合，每个进程都有自己的地址空间。<br><h3>2.交换技术</h3><br> 当内存超载时，可以使用交换技术：完成后的进程释放内存，给其他进<br> 程使用；或者虚拟内存技术：使程序在只有一部分被调入内存的情况下<br> 运行。<br> 当使用交换技术动态分配内存时，有两种方式追踪内存，位图和链表方式。<br> 分配内存的算法有：首次适配、下次适配、最佳适配方法等等。<br><h3> 3.虚拟内存</h3><br> 内存管理单元（MMU）：把虚拟地址映射为物理地址。虚拟内存是对物<br> 理地址的抽象，查找页表中的页表项可得，可使用转换检测缓冲区<br> （TLB）加速，<br><h3> 4.分页与分段</h3><br> 将用户程序的地址空间被划分成若干固定大小的区域，称为“页”。<br> 将程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整<br> 的逻辑信息，称为“段”。<br>区别：<br> (1)页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎<br> 片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含<br> 有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用<br> 户的需要.<br><br> (2)页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由<br> 机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常<br> 由编译程序在对源程序进行编译时根据信息的性质来划分.<br><br> (3)分页的作业地址空间是一维的.分段的地址空间是二维的.<br><br> 分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结<br> 构，便于段的共享与保护，将分页与分段两种存储方式结合起来，就形<br> 成了段页式存储管理方式。<br>段页式内存管理：<br> 在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分<br> 段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对<br> 于主存空间也分成大小相等的页，主存的分配以页为单位。为实现段页<br> 式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段<br> 的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页<br> 号和存放在主存中的物理块号。<br><h3> 5.页面置换算法</h3><br><h2 id="4">文件管理</h2><br><h3>1.文件</h3><br>文件是一种抽象机制，是磁盘上存储信息的抽象，是进程创建的信息逻辑单元。<br>磁盘的分配方式可分为连续分配，链表分配，索引分配，i节点等等方法。<br>软链接：可以看作快捷方式<br>硬链接：可以看作同一个文件两个文件名<br><h3>2.文件操作实例</h3><br><h3>3.目录</h3><br>目录用于记录文件，本身也是文件<br><h3> 4.文件系统管理优化</h3><br> 选择合适的块大小：太大浪费空间，太小耗费大量切换时间<br> 记录空闲块：链表与位图，如同内存管理<br> 限制磁盘配额：限制最大值<br> 文件系统备份：从意外或错误中恢复<br> 高速缓存：逻辑属于磁盘，但放在内存中<br> 块提前读：在用到块之前提前写入缓存<br> 磁盘碎片整理：移动文件使相邻，使空闲空间连续<br><h2 id="5">输入输出</h2><br><h3> 1.I/O设备</h3><br>字符设备：以字符为单位发送和接受信息<br>块设备：以块为单位进行传输<br><img src="https://github.com/chenper/chenper.github.com/blob/master/uploads/IO%E5%B1%82%E6%AC%A1.png" alt=""><br><h3> 2.DMA</h3><br> DMA(直接存储器存取)传输将数据从一个地址空间复制到另外一个地址<br> 空间，而不需要依赖CPU的中断将数据复制到寄存器再写回内存。<br><h3>3.I/O实现方式</h3><br> 程序控制I/O:cpu忙等待控制I/O的全部实现<br> 中断驱动I/O:当I/O完成时中断cpu进行工作<br> DMAI/O:由DMA控制器完成主要工作，减少cpu工作<br><h3>4.RAID</h3><br> 一组磁盘系统把它们看为一个单个的逻辑驱动器。数据分布在物理驱动<br> 器阵列中使用冗余的磁盘容量保存奇偶检验信息，保障一个磁盘失败<br> 时，数据具有可恢复性,可实现并行I/O。<br><h2 id="6">死锁</h2><br>如果一个进程集合中所有进程都在等待其他进程才能引发的事件，则称<br>该进程集合是死锁的。<br><h3>1.死锁条件</h3><br> 1. 互斥条件<br> 2. 不可抢占条件<br> 3. 占有与等待条件<br> 4. 环路等待条件<br><h3>2.鸵鸟算法</h3><br>假装没看到<br><h3> 3.死锁检测与死锁恢复</h3><br>允许死锁的发生，采取措施进行恢复，恢复方法有：利用抢占恢复；利用回滚恢复；利用杀死进程恢复。<br><h3>4.死锁避免</h3><br> 银行家算法：操作系统按照银行家制定的规则为进程分配资源，当进程<br> 首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的<br> 资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟<br> 分配。当进程在执行中继续申请资源时，先测试该进程本次申请的资源<br> 数是否超过了该资源所剩余的总量。若超过则拒绝分配资源，若能满足<br> 则按当前的申请量分配资源，否则也要推迟分配。<br><h3> 5.死锁预防</h3><br> 破坏互斥条件<br> 破坏占有和等待条件<br> 破坏不可抢占条件<br> 破坏环路等待条件<br><h2 id="7">Linux</h2> 
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/avatar.jpg"
               alt="陈皮糖" />
          <p class="site-author-name" itemprop="name">陈皮糖</p>
          <p class="site-description motion-element" itemprop="description">伴我同行</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈皮糖</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"chenper"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  

</body>
</html>
